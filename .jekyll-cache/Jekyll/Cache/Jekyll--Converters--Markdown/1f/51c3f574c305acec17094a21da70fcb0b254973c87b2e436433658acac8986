I"9<p><img src="/images/Contra-intro.png" alt="Contra Intro Graphic" /></p>

<p>In 1987, while I was busy dropping quarters in <a href="https://www.youtube.com/watch?v=zGaCLZCH-do">Contra</a>, Barbara Liskov was dropping her keynote address called <em>Data Abstraction and Hierarchy</em>. Her address contained concepts that have become known as the Liskov Substitution Principle (LSP). This principle governed ways to implement inheritance, polymorphism, and subclasses. Specifically:</p>

<blockquote>
  <p>Liskov’s notion of a behavioral subtype defines a notion of substitutability for objects; that is, if S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program (e.g. correctness). <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle#Principle">-wikipedia</a></p>
</blockquote>

<p>The way I interpret this is that we may replace the superclass with the subclass and the program should still operate correctly. A classic example that is typically used is the <code class="highlighter-rouge">rectangle</code> vs. <code class="highlighter-rouge">square</code> where the <code class="highlighter-rouge">square</code> “IS A” subclass of the <code class="highlighter-rouge">rectangle</code> (it’s just a special <code class="highlighter-rouge">rectangle</code> where the sides have equal length).</p>

<p>This violates the Liskov Substitution Principle when hypothetical methods like <code class="highlighter-rouge">setLength</code> and <code class="highlighter-rouge">setHeight</code> exist on <code class="highlighter-rouge">rectangle</code> (the superclass) and are inherited by <code class="highlighter-rouge">square</code> (the subclass). When implementing a <code class="highlighter-rouge">square</code>, we must make sure the properties <code class="highlighter-rouge">Length</code> and <code class="highlighter-rouge">Height</code> are equal which then violates an invariant of the base <code class="highlighter-rouge">rectangle</code> class. It’s expected in the superclass that <code class="highlighter-rouge">Length</code> and <code class="highlighter-rouge">Width</code> can be independent of each other.</p>

<p>Let’s go through an example using the video game Contra. Up to two people can play Contra at the same time. Each player can assume the role of a <code class="highlighter-rouge">Commando</code> named either Bill or Lance. Based on these rules, we might have the following class:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Commando</span>
  <span class="k">def</span> <span class="nf">talk</span>
    <span class="s1">''</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">shoot</span>
    <span class="s1">''</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>We can also define two subtypes to represent each player:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">PlayerOne</span> <span class="o">&lt;</span> <span class="no">Commando</span>
  <span class="k">def</span> <span class="nf">talk</span>
    <span class="s1">'Lance'</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">shoot</span>
    <span class="s1">'Bang Bang'</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">PlayerTwo</span> <span class="o">&lt;</span> <span class="no">Commando</span>
  <span class="k">def</span> <span class="nf">talk</span>
    <span class="s1">'Bill'</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">shoot</span>
    <span class="s1">'Pow Pow'</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Now we can attempt to substitute the subtypes (<code class="highlighter-rouge">PlayerOne</code> and <code class="highlighter-rouge">PlayerTwo</code>) where we were expecting the superclass (<code class="highlighter-rouge">Commando</code>):</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">playerOne</span> <span class="o">=</span> <span class="no">PlayerOne</span><span class="p">.</span><span class="nf">new</span>
<span class="n">playerTwo</span> <span class="o">=</span> <span class="no">PlayerTwo</span><span class="p">.</span><span class="nf">new</span>

<span class="k">def</span> <span class="nf">create_commando</span><span class="p">(</span><span class="n">commando</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">commando</span><span class="p">.</span><span class="nf">talk</span><span class="si">}</span><span class="s2"> here, my gun sound is - </span><span class="si">#{</span><span class="n">commando</span><span class="p">.</span><span class="nf">shoot</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="n">create_commando</span><span class="p">(</span><span class="n">playerOne</span><span class="p">)</span> <span class="c1"># Lance here, my gun sound is - Bang Bang</span>
<span class="n">create_commando</span><span class="p">(</span><span class="n">playerTwo</span><span class="p">)</span> <span class="c1"># Bill here, my gun sound is - Pow Pow</span></code></pre></figure>

<p>This is all looking pretty good. <code class="highlighter-rouge">PlayerOne</code> “IS A” <code class="highlighter-rouge">Commando</code> and Commandos can be replaced with the <code class="highlighter-rouge">PlayerOne</code> or <code class="highlighter-rouge">PlayerTwo</code> subtypes.</p>

<p>We can violate the Liskov Substitution Principle in Ruby easily by changing the return type in one of the subclasses which would make the substitution break. Suppose <code class="highlighter-rouge">PlayerTwo</code> is a medic. Still a <code class="highlighter-rouge">Commando</code>, but has a slightly different return type to the <code class="highlighter-rouge">shoot</code> method:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">PlayerTwo</span> <span class="o">&lt;</span> <span class="no">Commando</span>
  <span class="k">def</span> <span class="nf">talk</span>
    <span class="s1">'Bill'</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">shoot</span>
    <span class="p">{</span> <span class="ss">health: </span><span class="mi">50</span><span class="p">,</span> <span class="ss">food: </span><span class="mi">50</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Now <code class="highlighter-rouge">PlayerTwo</code> returns a hash instead of a string when the <code class="highlighter-rouge">shoot</code> method is called. That would break our <code class="highlighter-rouge">create_commando</code> code since we are expecting a <code class="highlighter-rouge">string</code>. A common code smell would be some code that type checks to see if we have <code class="highlighter-rouge">PlayerTwo</code> or <code class="highlighter-rouge">PlayerOne</code> and then deals with the change in return type accordingly. In cases where we see this, we should fix the inheritance gone wrong rather than work around the problem by type checking and changing the logic.</p>

<p>It’s interesting to see how closely related all the SOLID principles are and cases where an implementation to fix one violation may inadvertantly cause another violation.</p>
:ET