I"Ö9<p><img src="/images/multitools.jpg" alt="Multi Tool image" /></p>

<p>The Single Responsibility Principle says things that change for the same
reasons should be grouped together and things that change for different
reasons should be separated. Responsibility in this context should be
thought of as a reason for change. Prior to reading more about the SRP,
I assumed it meant that my class has one function. Instead, we should be
asking ourselves- what is the single reason why our class would change?</p>

<p>Given this construct, when examining the structure of my tic tac toe game,
there are a number of things I would change. When I first began, it made
sense that we needed a board class whose responsibility it would be to
keep state and tell me things about the board. Turns out using the word
‚Äúand‚Äù was a smell I should have picked up on. My board looked like this:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"> 
<span class="k">class</span> <span class="nc">Board</span> 

  <span class="no">EMPTY_CELL</span> <span class="o">=</span> <span class="s1">'-'</span>

  <span class="nb">attr_accessor</span> <span class="ss">:cells</span><span class="p">,</span> <span class="ss">:turn</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">cells</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="n">turn</span><span class="o">=</span> <span class="s2">"X"</span><span class="p">)</span>
    <span class="vi">@size</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="vi">@cells</span> <span class="o">=</span> <span class="n">cells</span> <span class="o">||</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@size</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="no">EMPTY_CELL</span><span class="p">)</span>
    <span class="vi">@turn</span> <span class="o">=</span> <span class="n">turn</span>
  <span class="k">end</span> 

  <span class="k">def</span> <span class="nf">length</span>
    <span class="vi">@cells</span><span class="p">.</span><span class="nf">length</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">display_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
    <span class="vi">@cells</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span>
  <span class="k">end</span>

<span class="c1"># some more methods</span>

<span class="k">end</span></code></pre></figure>

<p>I had a data structure to hold the contents of the board, keep track of who‚Äôs turn it was, and some other methods to change the state of the board. The mistake I made was including the <code class="highlighter-rouge">display_cell</code> method on the board instead of placing it in the UI class. I had assumed that the board class would tell me all sorts of things about the board including displaying the cell contents. We can clean this up by moving the responsibility of displaying what is on the board to the UI class.</p>

<p>Additionally, my board class tells me things about the board. Here are some more methods in the board class:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"> 

  <span class="k">def</span> <span class="nf">rows</span>
    <span class="vi">@cells</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="vi">@size</span><span class="p">).</span><span class="nf">to_a</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">columns</span>
    <span class="vi">@cells</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="vi">@size</span><span class="p">).</span><span class="nf">to_a</span><span class="p">.</span><span class="nf">transpose</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">main_diagonal</span>
    <span class="mi">0</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="vi">@cells</span><span class="p">.</span><span class="nf">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="vi">@size</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="vi">@cells</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">anti_diagonal</span>
    <span class="p">(</span><span class="vi">@size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span><span class="nf">step</span><span class="p">(</span><span class="vi">@cells</span><span class="p">.</span><span class="nf">length</span> <span class="o">-</span> <span class="vi">@size</span><span class="p">,</span> <span class="vi">@size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="vi">@cells</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">diagonals</span>
    <span class="p">[</span><span class="n">main_diagonal</span><span class="p">,</span> <span class="n">anti_diagonal</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">row_winner?</span>
    <span class="n">rows</span><span class="p">.</span><span class="nf">any?</span> <span class="p">{</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span> <span class="n">row</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="no">EMPTY_CELL</span> <span class="p">}}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">column_winner?</span>
    <span class="n">columns</span><span class="p">.</span><span class="nf">any?</span> <span class="p">{</span> <span class="o">|</span><span class="n">column</span><span class="o">|</span> <span class="n">column</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="no">EMPTY_CELL</span> <span class="p">}}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">diagonal_winner?</span>
    <span class="n">diagonals</span><span class="p">.</span><span class="nf">any?</span> <span class="p">{</span> <span class="o">|</span><span class="n">diagonal</span><span class="o">|</span> <span class="n">diagonal</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">diagonal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="no">EMPTY_CELL</span> <span class="p">}}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">tied?</span>
    <span class="vi">@cells</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">cell</span><span class="o">|</span> <span class="n">cell</span> <span class="o">!=</span> <span class="no">EMPTY_CELL</span> <span class="p">}</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">any_winner?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">any_winner?</span>
    <span class="n">row_winner?</span> <span class="o">||</span> <span class="n">column_winner?</span> <span class="o">||</span> <span class="n">diagonal_winner?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">who_won</span>
    <span class="k">if</span> <span class="n">column_winner?</span>
      <span class="n">columns</span><span class="p">.</span><span class="nf">find</span> <span class="p">{</span> <span class="o">|</span><span class="n">column</span><span class="o">|</span> <span class="n">column</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="p">}</span> <span class="p">}.</span><span class="nf">first</span>
    <span class="k">elsif</span> <span class="n">row_winner?</span>
      <span class="n">rows</span><span class="p">.</span><span class="nf">find</span> <span class="p">{</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span> <span class="n">row</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="p">}</span> <span class="p">}.</span><span class="nf">first</span>
    <span class="k">elsif</span> <span class="n">diagonal_winner?</span>
      <span class="n">diagonals</span><span class="p">.</span><span class="nf">find</span> <span class="p">{</span> <span class="o">|</span><span class="n">diagonal</span><span class="o">|</span> <span class="n">diagonal</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">diagonal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="p">}</span> <span class="p">}.</span><span class="nf">first</span>
    <span class="k">end</span>
  <span class="k">end</span></code></pre></figure>

<p>There are some methods to give me a collection of the rows, columns, and diagonals. There are also some methods that analyze those collections to see if there are winning rows, columns, or diagonals. You could definitely make the argument that some of this logic could be contained in a BoardEvaluator class. I could see this looking something like this:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">BoardEvaluator</span>
  
  <span class="k">def</span> <span class="nf">row_winner?</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
    <span class="n">board</span><span class="p">.</span><span class="nf">rows</span><span class="p">.</span><span class="nf">any?</span> <span class="p">{</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span> <span class="n">row</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="no">EMPTY_CELL</span> <span class="p">}}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">column_winner?</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
    <span class="n">board</span><span class="p">.</span><span class="nf">columns</span><span class="p">.</span><span class="nf">any?</span> <span class="p">{</span> <span class="o">|</span><span class="n">column</span><span class="o">|</span> <span class="n">column</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="no">EMPTY_CELL</span> <span class="p">}}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">diagonal_winner?</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
    <span class="n">board</span><span class="p">.</span><span class="nf">diagonals</span><span class="p">.</span><span class="nf">any?</span> <span class="p">{</span> <span class="o">|</span><span class="n">diagonal</span><span class="o">|</span> <span class="n">diagonal</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">diagonal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="no">EMPTY_CELL</span> <span class="p">}}</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>I‚Äôll definitely be cleaning up this class in the next refactor. We can see a clear violation of the Single Responsibility Principle with the display logic being in the class. We can also extract any evaluation of the state of the board into a BoardEvaluator class so that reason for change in the board class has to do with the state of the board. The reasons for changing how we determine a winner can be encapsulated in the BoardEvaluator class.</p>
:ET